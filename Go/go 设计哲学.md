---
title: go 设计哲学
tags:
  - learn
categories:
  - Go
date: 2025-06-20T15:46:26+08:00
draft: true
---
## Go 的一些理解

### 如何解决循环依赖（Circular Dependency）

#### 什么是循环依赖

- `package a` 导入了 `package b`
- `package b` 又反过来导入了 `package a`

```txt
  a.go           b.go
+--------+     +--------+
| package| --> | package|
|   a    |     |   b    |
|        | <-- |        |
+--------+     +--------+
```

依赖循环是设计的问题，如果遇到依赖的情况，需要重新思考该如何对项目进行设计。

#### 解决循环依赖

核心思想是 **打破循环**。Go 社区推崇的最佳实践是利用 **接口（Interface）** 和 **依赖倒置原则（Dependency Inversion Principle, DIP）**。

##### 方案一：使用接口（最推荐、最优雅的 "Go Way"）

依赖倒置原则的核心是 **“依赖于抽象，而不是依赖于具体实现”**。在 Go 中，这个“抽象”就是接口。

##### 方案二：提取公共依赖到新包

如果循环仅仅是因为共享了某个数据结构（struct），那么最简单的办法就是把这个公共的数据结构提取到一个新的、更底层的包里。

**警告**：不要滥用这个模式，避免创建一个什么都往里扔的“垃圾桶”(`common`, `utils`)包。这个新包应该只包含稳定、底层、被广泛依赖的数据结构或常量。

Pixiu 里不是什么东西都能放进 `model` 和 `common` 里的，这点需要注意，希望最后不用重构。

##### 方案三：使用回调函数

对于一些简单的依赖，使用回调函数是接口的一个轻量级替代方案。

**场景**：`user` 包中的一个函数需要 `order` 包的某个功能，但整体上 `user` 包并不想依赖 `order` 包。

事实上，回调函数即是依赖注入的函数。

#### 依赖注入（Dependency Injection, DI）解析

依赖注入的核心思想就是：一个组件（对象/结构体）**不应该**自己创建它所需要的依赖（其他组件），而**应该**由外部的、更高层次的组件来提供（“注入”）给它。

这种控制关系的反转（组件从主动创建依赖，变为被动接收依赖），也称为“**控制反转**”（Inversion of Control, IoC）。DI 是实现 IoC 的一种最常见的技术。

##### Go interface DI 中的`标准`

接口定义了**行为契约**：它只规定一个组件**应该能做什么**（有哪些方法），但不关心**具体是怎么做的**。

**隐式实现**：这是 Go 接口的精髓。任何类型，只要它实现了接口中定义的所有方法，就被认为自动满足了这个接口，无需使用 `implements` 这样的关键字。

