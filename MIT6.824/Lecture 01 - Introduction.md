---
title: Lecture 01 - Introduction
tags:
  - distribute
categories:
  - MIT6.824
date: 2025-01-05T15:23:22+08:00
draft: true
---
### 1.1 分布式系统的驱动力和挑战（Drives and Challenges）

#### 驱动

人们使用大量的相互协作的计算机驱动力是：

- **更高的计算性能**，而（大量的计算机意味着）大量的并行运算，大量CPU、大量内存、以及大量磁盘在并行的运行。
    
- **提供容错**（fault tolerance），比如两台计算机运行完全相同的任务，其中一台发生故障，可以切换到另一台。
    
- 一些问题天然在**空间上是分布的**。例如银行转账，我们假设银行A在纽约有一台服务器，银行B在伦敦有一台服务器，这就需要一种两者之间协调的方法。
    
- 人们构建分布式系**达成一些安全的目标**。比如有一些代码并不被信任，但是你又需要和它进行交互，这些代码不会立即表现的恶意或者出现 bug。你不会想要信任这些代码，所以你或许想要将代码分散在多处运行，这样你的代码在另一台计算机运行，我的代码在我的计算机上运行，我们通过一些特定的网络协议通信。所以，我们可能会担心安全问题，我们把系统分成多个的计算机，这样可以**限制出错域**。

#### 挑战

所有的这些分布式系统的问题（挑战）在于：

- 因为系统中存在很多部分，这些部分又在并发执行，你会遇到**并发编程**和各种**复杂交互**所带来的问题，以及**时间依赖**的问题（比如同步，异步）。
    
- 分布式系统有多个组成部分，再加上计算机网络，你会会遇到一些意想不到的故障。如果你只有一台计算机，那么它通常要么是工作，要么是故障或者没电，总的来说，要么是在工作，要么是没有工作。而由多台计算机组成的分布式系统，可能会有一部分组件在工作，而另一部分组件停止运行，或者这些计算机都在正常运行，但是网络中断了或者不稳定。所以，**局部错误**也是分布式系统很难的原因。
    
- 最后一个导致分布式系统很难的原因是，人们设计分布式系统的根本原因通常是为了获得更高的性能，比如说一千台计算机或者一千个磁盘臂达到的性能。但是实际上一千台机器到底有多少性能是一个棘手的问题，这里有很多难点。所以通常需要倍加小心地设计才能让系统实际达到你期望的性能。（如何设计以获取更高的性能）

### 1.2 课程结构（Course Structure）

阅读论文 完成四个 `lab`，并通过测试

### 1.3 分布式系统的抽象和实现工具（Abstraction and Implementation）

基础架构的类型主要是存储 `storage` ，通信（网络） `comms.` 和计算 `comp.` 。

`存储`，这是一个定义明确且有用的抽象概念。人们知道如何构建和使用储存系统，知道如何去构建一种多副本，容错的，高性能分布式存储实现。

随着课程的进行，我们会知道，很难能找到一个抽象来描述分布式的存储或者计算，使得它们能够像非分布式系统一样有简单易懂的接口。但是，人们在这方面的做的越来越好，我们会尝试学习人们在构建这样的抽象时的一些收获。(在分布式系统中用单体应用的方式来开发)

当我们在考虑这些抽象的时候，第一个出现的话题就是实现。人们在构建分布系统时，使用了很多的工具，例如：

- `RPC`（Remote Procedure Call）。RPC的目标就是掩盖我们正在不可靠网络上通信的事实。
    
- `线程` 是一种编程技术，使得我们可以利用多核心计算机。对于本课程而言，更重要的是，线程提供了一种`结构化的并发操作方式`，这样，从程序员角度来说可以简化并发操作。
    
- 考虑并发控制，比如`锁`。

### 1.4 可扩展性（Scalability）



